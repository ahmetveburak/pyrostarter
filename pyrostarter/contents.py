phrases = {
    "main": "from MODULE_NAME.BotConfig import BOT_NAME\n\nif __name__ == '__main__':\n    BOT_NAME().run()",
    "config": "[pyrogram]\nAPI_ID = api_id\nAPI_HASH = api_hash\nBOT_TOKEN = bot_token",
    "botconfig": 'from pyrogram import Client\nfrom pyrogram.types import Message\n\n\nclass BOT_NAME(Client, Message):\n    def __init__(self):\n        moduleName = "MODULE_NAME"\n        name = self.__class__.__name__.lower()\n        super().__init__(\n            session_name=name,\n            config_file=f"{moduleName}/{name}.ini",\n            workers=8,\n            plugins=dict(root=f"{moduleName}/plugins"),\n        )\n\n    async def start(self):\n        await super().start()\n\n    async def stop(self, *args):\n        await super().stop()\n',
    "plugin": 'from pyrogram import Client, filters\nfrom pyrogram.types import Message, CallbackQuery\nfrom functools import partial\nfrom MODULE_NAME.BotConfig import BOT_NAME\nfrom MODULE_NAME.utils import buttonator\nimport asyncio, time\n\ncommand = partial(filters.command, prefixes=["!", "/", "."])\n\n\n@BOT_NAME.on_message(command("start"))\nasync def say_hello(client: Client, message: Message) -> None:\n    msg = await message.reply_text(text="`Hello..`", quote=True)\n    await asyncio.sleep(1)\n    await msg.edit_text(text="`Hello I\'m Ready to Use`")\n\n\n@BOT_NAME.on_message(command("ping"))\nasync def ping(_, message: Message):\n    start = time.time()\n    reply = await message.reply_text("...")\n    delta_ping = time.time() - start\n    await reply.edit_text(f"**Pong!** `{delta_ping * 1000:.3f} ms`")\n\n\nmy_buttons = {\n    "Button1": "Button1",\n    "Button2": "Button2",\n    "Button3": "Button3",\n    "Button4": "Button4",\n    "Button5": "Button5",\n}\nbutton_filter = filters.create(lambda _, __, query: query.data in my_buttons.keys())\n\n\n@BOT_NAME.on_message(command("buttons"))\nasync def buttons(client: Client, message: Message):\n    me = await client.get_me()\n\n    if me.is_bot:\n        await message.reply_text(\n            text="These are test buttons with callback",\n            reply_markup=buttonator.button_maker(buttons=my_buttons, size=2),\n        )\n\n    else:\n        await message.reply_text(\n            text="Users can not send `keyboard markup`. **I\'m sorry..**",\n        )\n\n\n@BOT_NAME.on_callback_query(button_filter)\nasync def reply_callback(_: Client, callback=CallbackQuery):\n    await callback.message.reply_text(text=callback.data)\n',
    "util": "from pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup\n\n\ndef slicer(button_list: list, size: int) -> list:\n    return [button_list[i : i + size] for i in range(0, len(button_list), size)]\n\n\ndef button_maker(buttons: dict, size: int) -> InlineKeyboardMarkup:\n    buttons = [\n        InlineKeyboardButton(text=v, callback_data=k) for k, v in buttons.items()\n    ]\n    buttons = slicer(buttons, size)\n\n    return InlineKeyboardMarkup(buttons)\n",
}